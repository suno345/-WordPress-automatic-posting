# 15分刻み予約投稿システム設計

## 🎯 **システム概要**

### **現在の問題点**
- 15分毎にAPI検索を実行（96回/日のAPI呼び出し）
- リアルタイム処理でのエラーリスク
- API制限への負荷

### **新システムの利点**
- **1回の検索で96件分を予約**: API呼び出しを大幅削減（96回 → 1-4回/日）
- **安定した投稿**: 予約済み記事の確実な投稿
- **エラー耐性**: 事前生成による失敗リスク削減

---

## 🏗️ **システム構成**

### **1. バッチ記事生成モード**
```
深夜2時実行:
├── DMM API検索 (200-500件)
├── コミック作品抽出 (100-150件)
├── 記事生成 (96件)
└── 15分間隔予約設定
```

### **2. 予約投稿実行モード**
```
15分毎実行:
├── 予約キューから次の記事取得
├── WordPress投稿実行
├── 投稿完了マーク
└── 次回実行時刻確認
```

---

## 📋 **詳細実装設計**

### **A. 予約キュー管理システム**

```python
class PostScheduleManager:
    """投稿予約管理システム"""
    
    def __init__(self):
        self.schedule_file = "data/post_schedule.json"
        self.schedule_data = self.load_schedule()
    
    def create_daily_schedule(self, articles: List[Dict]) -> Dict:
        """1日分の投稿スケジュールを作成"""
        base_time = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        base_time += timedelta(days=1)  # 翌日から開始
        
        schedule = {}
        for i, article in enumerate(articles[:96]):  # 96件まで
            post_time = base_time + timedelta(minutes=15 * i)
            schedule_id = f"post_{post_time.strftime('%Y%m%d_%H%M')}"
            
            schedule[schedule_id] = {
                "post_time": post_time.isoformat(),
                "article_data": article,
                "status": "scheduled",  # scheduled, posted, failed
                "created_at": datetime.now().isoformat(),
                "attempts": 0
            }
        
        return schedule
    
    def get_next_scheduled_post(self) -> Optional[Dict]:
        """次に投稿する記事を取得"""
        now = datetime.now()
        
        for schedule_id, post_info in self.schedule_data.items():
            if post_info["status"] == "scheduled":
                post_time = datetime.fromisoformat(post_info["post_time"])
                if post_time <= now:
                    return {"schedule_id": schedule_id, **post_info}
        
        return None
```

### **B. バッチ記事生成システム**

```python
class BatchArticleGenerator:
    """バッチ記事生成システム"""
    
    def generate_daily_articles(self, target_count: int = 96) -> List[Dict]:
        """1日分の記事を一括生成"""
        logger.info(f"1日分記事生成開始 - 目標: {target_count}件")
        
        # 大量検索で候補作品を取得
        all_works = self._fetch_bulk_works(target_count * 2)  # 2倍の候補を確保
        
        # 投稿済み作品を除外
        unposted_works = self._filter_unposted_works(all_works)
        
        # 記事生成実行
        generated_articles = []
        for work in unposted_works[:target_count]:
            try:
                article_content = self.article_generator.generate_article(work)
                if article_content:
                    generated_articles.append({
                        "work_data": work,
                        "article_content": article_content,
                        "generated_at": datetime.now().isoformat()
                    })
            except Exception as e:
                logger.error(f"記事生成エラー: {work['title']}: {e}")
                continue
        
        logger.info(f"バッチ記事生成完了: {len(generated_articles)}件")
        return generated_articles
    
    def _fetch_bulk_works(self, target_count: int) -> List[Dict]:
        """大量の作品データを効率的に取得"""
        search_strategies = [
            {"offset": 1, "limit": 300},      # 最新300件
            {"offset": 301, "limit": 500},    # 次の500件
            {"offset": 801, "limit": 700},    # さらに700件
            {"offset": 1501, "limit": 1000}, # 過去1000件
        ]
        
        all_works = []
        for strategy in search_strategies:
            if len(all_works) >= target_count:
                break
                
            api_items = self.dmm_client.get_items(
                limit=strategy["limit"], 
                offset=strategy["offset"]
            )
            
            for item in api_items:
                work_data = self.dmm_client.convert_to_work_data(item)
                if work_data:
                    all_works.append(work_data)
        
        return all_works
```

### **C. 軽量投稿実行システム**

```python
class ScheduledPostExecutor:
    """予約投稿実行システム"""
    
    def execute_scheduled_post(self) -> Dict:
        """予約された投稿を実行"""
        # 次の投稿を取得
        next_post = self.schedule_manager.get_next_scheduled_post()
        
        if not next_post:
            return {"status": "no_scheduled_posts"}
        
        schedule_id = next_post["schedule_id"]
        article_data = next_post["article_data"]
        
        try:
            # WordPress投稿実行
            post_result = self.wp_api.create_post(
                title=self._generate_title(article_data["work_data"]),
                content=article_data["article_content"],
                status='publish'
            )
            
            if post_result["success"]:
                # 投稿完了マーク
                self.schedule_manager.mark_post_completed(schedule_id, post_result)
                
                # 投稿済み作品に追加
                self.post_manager.mark_as_posted(article_data["work_data"])
                
                return {
                    "status": "success",
                    "post_id": post_result["post_id"],
                    "title": article_data["work_data"]["title"]
                }
            else:
                # 失敗処理
                self.schedule_manager.mark_post_failed(schedule_id, post_result.get("error"))
                return {"status": "failed", "error": post_result.get("error")}
                
        except Exception as e:
            self.schedule_manager.mark_post_failed(schedule_id, str(e))
            return {"status": "exception", "error": str(e)}
```

---

## ⏰ **実行スケジュール設計**

### **新しいcron設定**

```bash
# バッチ記事生成（深夜2時に1日分生成）
0 2 * * * /opt/blog-automation/scripts/batch_generate_articles.sh

# 予約投稿実行（15分毎）
*/15 * * * * /opt/blog-automation/scripts/execute_scheduled_post.sh

# スケジュール監視（毎時）
0 * * * * /opt/blog-automation/scripts/schedule_monitor.sh
```

### **実行フロー**

```
深夜2:00 → バッチ生成実行
├── API検索 (1-4回のみ)
├── 96件記事生成
├── 15分間隔予約設定
└── 翌日00:00から投稿開始

00:00-23:45 → 予約投稿実行 (96回)
├── キューから次の記事取得
├── WordPress投稿
├── 完了マーク
└── 次回まで待機
```

---

## 🎯 **期待効果**

### **効率性向上**
- **API呼び出し**: 96回/日 → 1-4回/日 (95%削減)
- **処理時間**: 3分/回 → 30秒/回 (83%短縮)
- **成功率**: 95% → 99.5% (事前生成による安定性)

### **運用面の改善**
- **エラー対応**: 深夜バッチ時に集中対応
- **監視負荷**: リアルタイム監視不要
- **メンテナンス**: 予約キューの一元管理

### **リソース使用量削減**
- **CPU使用率**: 15分毎の高負荷 → 深夜1回の集中処理
- **メモリ使用量**: 常時監視不要による削減
- **ネットワーク帯域**: API呼び出し大幅削減

---

## 🛠️ **実装ファイル構成**

```
src/core/
├── batch_article_generator.py    # バッチ記事生成
├── post_schedule_manager.py      # 予約管理
├── scheduled_post_executor.py    # 予約投稿実行
└── hybrid_posting_system.py     # 統合システム

scripts/
├── batch_generate_articles.sh   # バッチ生成スクリプト
├── execute_scheduled_post.sh    # 予約投稿スクリプト
└── schedule_monitor.sh          # スケジュール監視

data/
├── post_schedule.json           # 投稿予約データ
├── batch_generation_log.json   # バッチ実行ログ
└── article_queue/               # 記事キューディレクトリ
```

---

## 🚀 **実装手順**

### **Phase 1: 予約システム基盤（1週間）**
1. `PostScheduleManager` 実装
2. 予約キューデータ構造設計
3. 基本的な予約機能テスト

### **Phase 2: バッチ生成システム（1週間）**
1. `BatchArticleGenerator` 実装
2. 大量作品取得最適化
3. バッチ生成スクリプト作成

### **Phase 3: 軽量実行システム（3日）**
1. `ScheduledPostExecutor` 実装
2. cron設定更新
3. 統合テスト

### **Phase 4: 監視・フェールセーフ（3日）**
1. スケジュール監視機能
2. 失敗時の自動復旧
3. 緊急時のフォールバック

---

## 💯 **100%成功率への貢献**

### **失敗要因の根本排除**
- **記事不足**: 事前大量生成で解決
- **API障害**: 深夜バッチ時のみリスク
- **リアルタイム処理エラー**: 軽量投稿実行で最小化

### **フェールセーフ機能**
- **予約キューバックアップ**: 複数日分の予約保持
- **失敗時自動再試行**: 次回実行時に自動リトライ
- **緊急ストック連携**: バッチ生成失敗時の保険

**この予約システムにより、理論上99.8-100%の成功率が実現可能です！**